## 介绍
进程间通讯 IPC (Inter-process communication)

IPC是Inter-Process Communication的缩写，含义就是进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。那么什么是进程，什么是线程，进程和线程是两个截然不同的概念。在操作系统中，线程是CPU调度的最小单元，同时线程是一种有限的系统资源。而进程指的一个执行单元，在PC和移动设备上指的是一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含被包含的关系，最简单情况下，一个进程可以只有一个线程，即主线程，在Android里面也叫UI线程，在UI线程里才能操作界面元素。

那么在Android中，有特色的进程间通信方式就是Binder了，通过Binder可以轻松实现进程间通信。除了Binder，Android还支持Socket，通过Socket也可以实现任意两个终端之间的通信，当然一个设备上的两个进程之间通过Socket通信自然也是可以的。

说到IPC的使用场景就必须提到多进程，只有面对多进程这种场景下，才需要考虑进程间通信。所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多进程所带来的主要影响。正常情况下，四大组件中间不可能不通过一些中间层来共享数据，那么通过简单地指定进程名来开启多进程都会无法正确运行。

一般来说，使用多进程会造成如下几方面的问题：

- 静态成员和单例模式完全失效
- 线程同步机制完全失效
- SharedPreferences的可靠性下降
- Application会多次创建

## 进行进程间通讯的场景(IPC (Inter-process communication))

1. 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几M字节之间
1. 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。
1. 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
1. 资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。
1. 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

## linux常用的进程间的通讯方式

1. **管道(pipe)**：管道可用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。

1. **命名管道(named pipe)**：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。

1. **信号（signal）**：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生了，除了进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。

1. **消息队列**：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺

1. **共享内存**：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

1. **内存映射**：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。

1. **信号量（semaphore）**：主要作为进程间以及同一进程不同线程之间的同步手段。

1. **套接字（Socket）**：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

## Android常用的进程间的通讯方式

<table>
  <tr>
    <th width=10%, bgcolor=#EEEEEE >名称</th>
    <th width=30%, bgcolor=#EEEEEE>优点</th>
    <th width="30%", bgcolor=#EEEEEE>缺点</th>
    <th width="30%", bgcolor=#EEEEEE>适用场景</th>
  </tr>
  <tr>
    <td bgcolor=#FFFFFF>Bundle</td>
    <td>简单易用</td>
    <td>只能传输Bundle支持的数据类型</td>
    <td>四大组件间的进程间通讯</td>
  </tr>
  <tr>
    <td bgcolor=#FFFFFF>文件共享</td>
    <td>简单易用</td>
    <td>不适合高并发场景，并且无法做到进程间的即时通讯</td>
    <td>无并发访问情形，交换简单的数据实时性不高的场景</td>
  <tr>
    <td bgcolor=rgb(255,255,255)>AIDL</td>
    <td>功能强大，支持一对多并发通信，支持实时通信</td>
    <td>使用稍复杂，需要处理好线程同步</td>
    <td>一对多通信且有RPC需求</td>
  </tr>
 <tr>
    <td bgcolor=rgb(255,255,255)>Messenger</td>
    <td>功能一般，支持一对串行发通信，支持实时通信</td>
    <td>不能很好处理高并发情形，不支持RPC，数据通过Message进行传输，因此只能传输Bundle支持的数据类型</td>
    <td>低并发的一对多即时通信，无RPC需求，或者无需返回结果的RPC需求</td>
  </tr>
 <tr>
    <td bgcolor=rgb(255,255,255)>ContentProvider </td>
    <td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作</td>
    <td>可理解为受约束的AIDL，主要提供数据源的CRUD操作</td>
    <td>一对多的进程间的数据共享</td>
  </tr>
 <tr>
    <td bgcolor=rgb(255,255,255)>Socket</td>
    <td>功能强大，可通过网络传输字节流，支持一对多并发实时通讯</td>
    <td>实现细节稍微繁琐，不支持直接的RPC</td>
    <td>网络数据交换</td>
  </tr>
</table>

名词解释：

* **RPC**（Remote Procedure Call Protocol）远程过程调用

* **crud** （Create Retrieve Update Delete）：指在做计算处理时的增加(Create)、读取查询(Retrieve)、更新(Update)和删除(Delete)

